Project: Cypher Validation Library

Goal:
Build a Rust-based Cypher validation library with Python bindings using PyO3. The purpose of the library is to validate LLM-generated Cypher queries by performing syntax and schema validation, and exposing structured diagnostics.

Functionality:
- Parse and validate Cypher queries using an ANTLR-generated parser
- Load graph schema from JSON (or Neo4j via Cypher query in future)
- Validate:
  - Node labels
  - Relationship types
  - Property existence
  - Property values (enums, ranges)
- Identify write queries
- Optionally suggest or correct issues (e.g., wrong relationship direction)

Deliverables:
- Rust crate: cypher_guard
- Python package (via maturin): cypher_guard
- CLI binary for validating queries from stdin (optional)
- Unit tests for all public functions

Modules and Key Functions:
- syntax.rs
  - fn validate_syntax(query: &str) -> Result<(), ValidationError>
  - fn is_write_query(query: &str) -> bool
- schema.rs
  - struct DbSchema { ... }
  - fn validate_node_label(label: &str, schema: &DbSchema) -> Result<(), ValidationError>
  - fn validate_relationship_type(...)
  - fn validate_property_exists(...)
  - fn validate_property_value(...)
- loader.rs
  - fn load_schema_from_json(path: &str) -> Result<DbSchema, Error>
- lib.rs (Python bindings)
  - #[pyfunction] fn validate_query(...)

Build and Tooling:
- Rust 2021 Edition
- Python bindings built via pyo3 and maturin
- Crate type is cdylib for FFI compatibility
- Uses pyo3/extension-module feature
- Tests runnable via cargo test
- Python wheel installable with: maturin develop
- CLI binary buildable via: cargo build --bin cypher_guard_cli
- Cypher parser generated using antlr4rust

Future Enhancements:
- Add strict_mode flag to toggle between warnings and hard errors
- Support multiple-statement Cypher parsing
- Include position info in diagnostics (line, column)
- Track query variables and alias usage across clauses
- Relationship direction inference + auto-correction
- Property format validation (regex)
- Support schema load from live Neo4j via Cypher query

Out of Scope (for now):
- Autocompletion
- Signature help
- Formatting
- LSP integration

External References:
- https://github.com/neo4j/cypher-language-support
- https://github.com/neo4j-field/ps-genai-agents
- https://github.com/neo4j/neo4j-graphrag-python

## Cypher Parser Implementation

### Background & Rationale

The Cypher query language is central to the functionality of this project. While robust language tooling exists for Cypher in JavaScript/TypeScript (e.g., Neo4j's `@neo4j-cypher/language-support`), there is currently no mature, production-ready Cypher parser or validator available in Rust. Existing Rust libraries (such as `cypher-rs`) are incomplete and do not provide the level of syntax validation, error diagnostics, or schema integration required for this project.

### Requirement

To ensure that Cypher queries can be validated for both syntax and schema compliance within a Rust-based system, we will implement a custom Cypher parser in Rust. This parser will serve as the foundation for all query validation, error reporting, and (eventually) features such as autocomplete and query analysis.

### Goals

- Parse Cypher queries into an Abstract Syntax Tree (AST) using a Rust-native parser.
- Validate Cypher syntax and provide meaningful error messages for invalid queries.
- Support incremental grammar expansion (start with basic queries, add more features over time).
- Integrate with schema validation to ensure queries reference only valid labels, relationship types, and properties.

### Out of Scope

- Full feature parity with Neo4j's official language tooling (at least initially).
- Advanced features such as autocomplete, linting, or query optimization (may be considered in future phases).

### Approach

- Use a Rust parser combinator library (e.g., `pest` or `nom`) to define the Cypher grammar.
- Start with a minimal subset of Cypher (e.g., `MATCH`, `RETURN`, node/relationship patterns).
- Incrementally add support for additional Cypher features (e.g., `WHERE`, `CREATE`, `DELETE`, expressions).
- Build and maintain a Rust AST for Cypher queries.
- Write comprehensive unit and integration tests for all supported grammar features.
- Document parser usage, limitations, and roadmap for future expansion.

### Risks & Considerations

- Building a parser is a significant technical investment and may impact project timelines.
- The Cypher language is complex and evolving; ongoing maintenance will be required.
- Some advanced Cypher features may be deferred or omitted based on project needs.
