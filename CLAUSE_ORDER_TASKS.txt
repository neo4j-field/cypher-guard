# Cypher Clause Order Validation - Implementation Tasks

## Overview
This document outlines all tasks required to implement proper clause ordering validation in the Cypher parser. Currently, the parser accepts invalid clause orders like "RETURN a MATCH (a)" which should be syntax errors.

## Task Priority Order (Recommended Implementation Sequence)

### PHASE 1: Basic Order Validation (4-6 hours)
**Goal**: Add fundamental clause order validation with basic error handling

1. **Add Clause Order Validation Function**
   - Create `validate_clause_order(clauses: &[Clause]) -> Result<(), CypherGuardParsingError>`
   - Implement basic Cypher clause order rules:
     - MATCH/OPTIONAL MATCH must come first (reading clauses)
     - UNWIND can come after MATCH
     - WHERE can come after MATCH/UNWIND
     - WITH can come after WHERE
     - RETURN must come last (except for writing clauses)
     - CREATE/MERGE can come after RETURN (writing clauses)

2. **Update Parser to Call Validation**
   - Modify `parse_query()` in `src/parser/clauses.rs`
   - Call validation function after parsing clauses
   - Return `InvalidClauseOrder` error for violations

3. **Add Basic Error Handling**
   - Use existing `InvalidClauseOrder` error variant
   - Add basic error messages like "RETURN must come after MATCH"

4. **Write Basic Tests**
   - Test valid clause orders: `MATCH (a) RETURN a`
   - Test invalid clause orders: `RETURN a MATCH (a)` (should fail)
   - Test edge cases: empty queries, single clauses

### PHASE 2: Enhanced Error Types (3-4 hours)
**Goal**: Provide more specific and helpful error messages

5. **Add Specific Error Variants** [COMPLETED]
   - `ClauseInWrongPosition { clause: String, found_at: usize, expected_positions: Vec<String> }`
   - `MissingRequiredClause { clause: String, context: String }`
   - `DuplicateClause { clause: String, first_position: usize, second_position: usize }`
   - `InvalidClauseSequence { found_sequence: Vec<String>, expected_sequence: Vec<String> }`

6. **Implement Position Tracking**
   - Track byte offsets during parsing
   - Convert to line/column numbers for error messages
   - Add position info to error messages: "RETURN found at line 1, column 15"

7. **Improve Error Messages**
   - More descriptive messages: "WHERE clause must come after MATCH or UNWIND"
   - Context-aware suggestions: "Did you mean to put MATCH before RETURN?"

### PHASE 3: Multiple Clause Support (4-5 hours)
**Goal**: Handle multiple clauses of the same type correctly

8. **Update AST Structure**
   - Change `Query` struct from individual `Option<Clause>` fields to `Vec<Clause>`
   - Or add support for multiple clauses per type: `Vec<MatchClause>`, `Vec<WhereClause>`, etc.

9. **Handle Multiple Clauses**
   - Multiple MATCH: `MATCH (a) MATCH (b) RETURN a, b`
   - Multiple WHERE: `MATCH (a) WHERE a.age > 30 WHERE a.active = true`
   - Multiple WITH: `MATCH (a) WITH a WHERE a.age > 30 WITH a.age AS age RETURN age`

10. **Update Validation Logic**
    - Modify `extract_query_elements()` to handle multiple clauses
    - Update `validate_query_elements()` for new structure
    - Ensure all existing validation still works

### PHASE 4: Advanced Features (6-8 hours)
**Goal**: Add sophisticated validation rules and query type detection

11. **Implement Clause Dependencies**
    - WHERE requires MATCH/UNWIND before it
    - RETURN requires at least one reading clause
    - WITH can't be the last clause (unless followed by RETURN)
    - CREATE/MERGE can't come before MATCH (unless write-only query)

12. **Add Query Type Detection**
    - Distinguish read-only vs write queries
    - Different validation rules for each type
    - Read-only: MATCH → WHERE → WITH → RETURN
    - Write: MATCH → WHERE → CREATE/MERGE → RETURN (optional)

13. **Support Subquery Validation**
    - Handle clause ordering within subqueries
    - Example: `MATCH (a) WHERE EXISTS { MATCH (a)-[:KNOWS]->(b) RETURN b } RETURN a`
    - Nested clause validation logic

14. **Add Error Recovery Suggestions**
    - Provide helpful suggestions for fixing errors
    - "Did you mean to put MATCH before RETURN?"
    - "WHERE clause must come after MATCH"
    - "Multiple MATCH clauses are allowed, but RETURN must come last"

### PHASE 5: Polish and Optimization (2-3 hours)
**Goal**: Performance optimization and final touches

15. **Performance Optimization**
    - Early termination on first violation
    - Efficient state tracking during validation
    - Optimize for large queries with many clauses

16. **Backward Compatibility**
    - Ensure existing valid queries continue to work
    - Don't break existing test cases
    - Maintain API compatibility

17. **Documentation Updates**
    - Update API documentation
    - Add error message examples
    - Create migration guide if needed
    - Document best practices

18. **Integration Testing**
    - Test with real-world complex queries
    - Performance benchmarks
    - Error message quality tests
    - Edge case coverage

## Additional Considerations

### Error Handling Infrastructure
- ✅ Basic error types already exist in `src/errors.rs`
- ✅ `InvalidClauseOrder` variant already defined
- ✅ Error conversion functions exist for Python/JS bindings

### Testing Strategy
- Unit tests for each validation rule
- Integration tests for complex queries
- Performance tests for large queries
- Error message quality tests

### API Impact
- Public API functions remain unchanged
- Internal AST structure may change
- Error messages become more specific

### Risk Mitigation
- Start with Phase 1 (lowest risk)
- Maintain existing functionality throughout
- Comprehensive testing at each phase
- Gradual migration approach

## Success Criteria
1. Invalid clause orders are rejected with clear error messages
2. Valid clause orders continue to work
3. Multiple clauses of same type are handled correctly
4. Error messages are helpful and actionable
5. Performance remains acceptable
6. All existing tests pass
7. New tests cover clause ordering scenarios

## Estimated Timeline
- **Phase 1**: 1 day
- **Phase 2**: 1 day  
- **Phase 3**: 1-2 days
- **Phase 4**: 2-3 days
- **Phase 5**: 1 day
- **Total**: 6-8 days of focused development

## Notes
- Start with Phase 1 for immediate value with lowest risk
- Each phase builds on the previous one
- Can stop at any phase if time/budget constraints
- Consider breaking into smaller PRs for easier review 