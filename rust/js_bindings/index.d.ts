/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/**
 * Validate a Cypher query against a schema.
 *
 * @param query - The Cypher query string to validate
 * @param schema_json - JSON schema string
 * @returns True if the query is valid according to the schema
 * @throws Error if validation fails due to schema violations or parsing errors
 */
export declare function validateCypher(
  query: string,
  schemaJson: string
): boolean;
/**
 * Get all validation errors for a Cypher query against a schema.
 *
 * @param query - The Cypher query string to validate
 * @param schema_json - JSON schema string
 * @returns Array of validation error messages. Empty array if query is valid.
 */
export declare function getValidationErrors(
  query: string,
  schemaJson: string
): Array<string>;
/**
 * Parse a Cypher query into an Abstract Syntax Tree (AST).
 *
 * @param query - The Cypher query string to parse
 * @returns The parsed AST as a JavaScript object (currently returns empty object)
 * @throws Error if the query has syntax errors and cannot be parsed
 */
export declare function parseQuery(query: string): NapiResult;
/**
 * Fast validation check - returns true if query is valid, false if it has any errors.
 * Optimized for validation loops where you only need to know if the query is valid.
 *
 * @param query - The Cypher query string to validate
 * @param schema_json - JSON schema string
 * @returns True if query is completely valid, false if it has any validation or parsing errors
 */
export declare function hasValidCypher(
  query: string,
  schemaJson: string
): boolean;
/** JavaScript wrapper for PropertyType enum */
export interface PropertyType {
  typeName: string;
}
/** JavaScript wrapper for DbSchemaProperty */
export interface DbSchemaProperty {
  name: string;
  neo4JType: string;
  enumValues?: Array<string>;
  minValue?: number;
  maxValue?: number;
  distinctValueCount?: number;
  exampleValues?: Array<string>;
}
/** JavaScript wrapper for DbSchemaRelationshipPattern */
export interface DbSchemaRelationshipPattern {
  start: string;
  end: string;
  relType: string;
}
/** JavaScript wrapper for DbSchemaConstraint */
export interface DbSchemaConstraint {
  id: number;
  name: string;
  constraintType: string;
  entityType: string;
  labels: Array<string>;
  properties: Array<string>;
}
/** JavaScript wrapper for DbSchemaIndex */
export interface DbSchemaIndex {
  label: string;
  properties: Array<string>;
  size: number;
  indexType: string;
}
/** JavaScript wrapper for DbSchemaMetadata */
export interface DbSchemaMetadata {
  constraint: Array<DbSchemaConstraint>;
  index: Array<DbSchemaIndex>;
}
/** JavaScript wrapper for DbSchema */
export interface DbSchema {
  nodeProps: Record<string, Array<DbSchemaProperty>>;
  relProps: Record<string, Array<DbSchemaProperty>>;
  relationships: Array<DbSchemaRelationshipPattern>;
  metadata: DbSchemaMetadata;
}
/**
 * Create a new DbSchema from a JSON string
 *
 * @param json_str - JSON string representing the schema
 * @returns DbSchema object
 */
export declare function dbSchemaFromJsonString(jsonStr: string): DbSchema;
/**
 * Create a new empty DbSchema
 *
 * @returns Empty DbSchema object
 */
export declare function dbSchemaNew(): DbSchema;
/**
 * Check if a schema has a specific label
 *
 * @param schema - The DbSchema object
 * @param label - Label to check for
 * @returns True if the label exists in the schema
 */
export declare function dbSchemaHasLabel(
  schema: DbSchema,
  label: string
): boolean;
/**
 * Check if a schema has a specific node property
 *
 * @param schema - The DbSchema object
 * @param label - Node label
 * @param property - Property name to check for
 * @returns True if the property exists on the label
 */
export declare function dbSchemaHasNodeProperty(
  schema: DbSchema,
  label: string,
  property: string
): boolean;
/**
 * Create a new DbSchemaProperty
 *
 * @param name - Property name
 * @param neo4j_type - Property type (STRING, INTEGER, etc.)
 * @returns DbSchemaProperty object
 */
export declare function dbSchemaPropertyNew(
  name: string,
  neo4JType: string
): DbSchemaProperty;
/**
 * Create a new DbSchemaRelationshipPattern
 *
 * @param start - Start node label
 * @param end - End node label
 * @param rel_type - Relationship type
 * @returns DbSchemaRelationshipPattern object
 */
export declare function dbSchemaRelationshipPatternNew(
  start: string,
  end: string,
  relType: string
): DbSchemaRelationshipPattern;
/**
 * Create a new empty DbSchemaMetadata
 *
 * @returns Empty DbSchemaMetadata object
 */
export declare function dbSchemaMetadataNew(): DbSchemaMetadata;
/**
 * Create a new DbSchemaConstraint
 *
 * @param id - Constraint ID
 * @param name - Constraint name
 * @param constraintType - Type of constraint (e.g., "UNIQUE", "EXISTS")
 * @param entityType - Entity type (node or relationship)
 * @param labels - Labels or relationship types affected
 * @param properties - Properties affected by the constraint
 * @returns DbSchemaConstraint object
 */
export declare function dbSchemaConstraintNew(
  id: number,
  name: string,
  constraintType: string,
  entityType: string,
  labels: Array<string>,
  properties: Array<string>
): DbSchemaConstraint;
/**
 * Create a new DbSchemaIndex
 *
 * @param label - Index label (node type)
 * @param properties - Properties included in the index
 * @param size - Size of the index
 * @param indexType - Type of index (e.g., "BTREE", "TEXT")
 * @returns DbSchemaIndex object
 */
export declare function dbSchemaIndexNew(
  label: string,
  properties: Array<string>,
  size: number,
  indexType: string
): DbSchemaIndex;
export interface StructuredErrorCategories {
  schemaErrors: Array<string>;
  propertyErrors: Array<string>;
  syntaxErrors: Array<string>;
  typeErrors: Array<string>;
  parsingErrors: Array<string>;
}
export interface StructuredErrors {
  hasErrors: boolean;
  errorCount: number;
  categories: StructuredErrorCategories;
  query: string;
  suggestions: Array<string>;
}
/**
 * Get structured validation errors optimized for LLM feedback.
 * Returns categorized error information to help LLMs generate better corrections.
 *
 * @param query - The Cypher query string to validate
 * @param schema_json - JSON schema string
 * @returns Structured error information with categories and suggestions
 */
export declare function getStructuredErrors(
  query: string,
  schemaJson: string
): StructuredErrors;
